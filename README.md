#ðŸ“Š **Computational Number Theory & Performance Analysis**

#**Overview**

This project is a comprehensive collection of Python functions implemented within a single Jupyter Notebook (ProgramCodes.ipynb). It serves as a computational library focusing primarily on Number Theory (primes, factorization, divisibility, properties of numbers) and Advanced Computational Mathematics (sequences, modular arithmetic, approximations).

The primary goal is to provide runnable, self-contained implementations of these mathematical concepts, with a strong emphasis on measuring and analyzing algorithmic performance. Each function is instrumented using Python's built-in time and tracemalloc modules to calculate Execution Time and Peak Memory Usage, offering basic, yet crucial, insights into the efficiency of each algorithm.

**Features**

**The library includes functions categorized into five main areas:**

**1. Number Properties & Classification**

Covers fundamental characteristics and classifications of integers:

Classification: Checking for properties like Palindromic, Abundant, Deficient, Harshad, Automorphic, and Pronic numbers.

Calculations: Finding the Factorial, Mean of Digits, and Digital Root.

Testing: Checking if a number is a Perfect Power.

**2. Prime Numbers & Factorization**

Includes foundational and advanced algorithms essential for number theoretic computations:

Basic Factorization: Calculating Prime Factors and Counting Distinct Prime Factors.

Primality Testing: Testing for Prime Power and Mersenne Primes.

Advanced Algorithms: Advanced primality testing using the Miller-Rabin Algorithm and factorization using the Pollard's Rho Algorithm.

Special Numbers: Generating Twin Primes and checking for Carmichael Numbers.

**3. Divisibility & Modular Arithmetic**

Focuses on the relationships between integers and arithmetic operations:

Divisors: Calculating Aliquot Sum (sum of proper divisors) and Count Divisors.

Special Pairs: Checking for Amicable Numbers.

Modular Operations: Efficiently calculating Modular Exponentiation (mod_exp), finding the Modular Multiplicative Inverse and the Multiplicative Order.

Residues: Checking for Quadratic Residues.

Note: An incomplete implementation of the Chinese Remainder Theorem (CRT) is included.

**4. Sequences & Iterative Processes**

Functions dealing with iterative patterns and famous sequences:

Calculating the length of the Collatz Sequence.

Generating the Lucas Sequence.

Calculating Multiplicative Persistence.

Calculating the $n$-th Polygonal Number.

Checking for Fibonacci Primes.

**5. Advanced Computational Math**

Implementations of more complex mathematical functions:

Approximation of the Riemann Zeta function ($\zeta(s)$).

Computation of the Partition Function $p(n)$.
